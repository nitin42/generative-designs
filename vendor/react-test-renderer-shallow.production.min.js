/** @license React v16.4.1
 * react-test-renderer-shallow.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict'
;(function(g, f) {
  'object' === typeof exports && 'undefined' !== typeof module
    ? (module.exports = f(require('react')))
    : 'function' === typeof define && define.amd
      ? define(['react'], f)
      : (g.ReactShallowRenderer = f(g.React))
})(this, function(g) {
  function f(a, b, d, c, e, h, g, x) {
    if (!a) {
      a = void 0
      if (void 0 === b)
        a = Error(
          'Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.'
        )
      else {
        var w = [d, c, e, h, g, x],
          f = 0
        a = Error(
          b.replace(/%s/g, function() {
            return w[f++]
          })
        )
        a.name = 'Invariant Violation'
      }
      a.framesToPop = 1
      throw a
    }
  }
  function n(a) {
    for (
      var b = arguments.length - 1,
        d = 'https://reactjs.org/docs/error-decoder.html?invariant=' + a,
        c = 0;
      c < b;
      c++
    )
      d += '&args[]=' + encodeURIComponent(arguments[c + 1])
    f(
      !1,
      'Minified React error #' +
        a +
        '; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ',
      d
    )
  }
  function q(a) {
    if ('object' === typeof a && null !== a) {
      var b = a.$$typeof
      switch (b) {
        case y:
          switch (((a = a.type), a)) {
            case z:
            case A:
            case B:
            case C:
              return a
            default:
              switch (((a = a && a.$$typeof), a)) {
                case D:
                case p:
                case E:
                  return a
                default:
                  return b
              }
          }
        case F:
          return b
      }
    }
  }
  function r(a, b) {
    return a === b ? 0 !== a || 0 !== b || 1 / a === 1 / b : a !== a && b !== b
  }
  function t(a, b) {
    if (r(a, b)) return !0
    if (
      'object' !== typeof a ||
      null === a ||
      'object' !== typeof b ||
      null === b
    )
      return !1
    var d = Object.keys(a),
      c = Object.keys(b)
    if (d.length !== c.length) return !1
    for (c = 0; c < d.length; c++)
      if (!G.call(b, d[c]) || !r(a[d[c]], b[d[c]])) return !1
    return !0
  }
  function u(a, b) {
    if (!(a instanceof b))
      throw new TypeError('Cannot call a class as a function')
  }
  var v = g.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
    e = 'function' === typeof Symbol && Symbol.for,
    y = e ? Symbol.for('react.element') : 60103,
    F = e ? Symbol.for('react.portal') : 60106,
    A = e ? Symbol.for('react.fragment') : 60107,
    C = e ? Symbol.for('react.strict_mode') : 60108,
    B = e ? Symbol.for('react.profiler') : 60114,
    E = e ? Symbol.for('react.provider') : 60109,
    D = e ? Symbol.for('react.context') : 60110,
    z = e ? Symbol.for('react.async_mode') : 60111,
    p = e ? Symbol.for('react.forward_ref') : 60112
  e && Symbol.for('react.placeholder')
  var G = Object.prototype.hasOwnProperty,
    l = {},
    m = (function() {
      function a() {
        u(this, a)
        this._rendered = this._newState = this._instance = this._element = this._context = null
        this._forcedUpdate = this._rendering = !1
        this._updater = new H(this)
      }
      a.prototype.getMountedInstance = function() {
        return this._instance
      }
      a.prototype.getRenderOutput = function() {
        return this._rendered
      }
      a.prototype.render = function(b) {
        var a =
          1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : l
        g.isValidElement(b)
          ? void 0
          : n(
              '12',
              'function' === typeof b
                ? ' Instead of passing a component class, make sure to instantiate it by passing it to React.createElement.'
                : ''
            )
        'string' === typeof b.type ? n('13', b.type) : void 0
        q(b) !== p && 'function' !== typeof b.type
          ? n(
              '249',
              Array.isArray(b.type)
                ? 'array'
                : null === b.type
                  ? 'null'
                  : typeof b.type
            )
          : void 0
        if (!this._rendering) {
          this._rendering = !0
          this._element = b
          var c = b.type.contextTypes
          if (c) {
            var e = {},
              h
            for (h in c) e[h] = a[h]
            a = e
          } else a = l
          this._context = a
          this._instance
            ? this._updateClassComponent(b, this._context)
            : q(b) === p
              ? (this._rendered = b.type.render(b.props, b.ref))
              : ((a = b.type),
                a.prototype && a.prototype.isReactComponent
                  ? ((this._instance = new b.type(
                      b.props,
                      this._context,
                      this._updater
                    )),
                    this._updateStateFromStaticLifecycle(b.props),
                    b.type.hasOwnProperty('contextTypes'),
                    this._mountClassComponent(b, this._context))
                  : (this._rendered = b.type.call(
                      void 0,
                      b.props,
                      this._context
                    )))
          this._rendering = !1
          this._updater._invokeCallbacks()
          return this.getRenderOutput()
        }
      }
      a.prototype.unmount = function() {
        this._instance &&
          'function' === typeof this._instance.componentWillUnmount &&
          this._instance.componentWillUnmount()
        this._instance = this._rendered = this._newState = this._element = this._context = null
      }
      a.prototype._mountClassComponent = function(b, a) {
        this._instance.context = a
        this._instance.props = b.props
        this._instance.state = this._instance.state || null
        this._instance.updater = this._updater
        if (
          'function' === typeof this._instance.UNSAFE_componentWillMount ||
          'function' === typeof this._instance.componentWillMount
        )
          (a = this._newState),
            'function' !== typeof b.type.getDerivedStateFromProps &&
              'function' !== typeof this._instance.getSnapshotBeforeUpdate &&
              ('function' === typeof this._instance.componentWillMount &&
                this._instance.componentWillMount(),
              'function' === typeof this._instance.UNSAFE_componentWillMount &&
                this._instance.UNSAFE_componentWillMount()),
            a !== this._newState && (this._instance.state = this._newState || l)
        this._rendered = this._instance.render()
      }
      a.prototype._updateClassComponent = function(b, a) {
        var c = b.props,
          d = b.type,
          e = this._instance.state || l,
          g = this._instance.props
        g !== c &&
          'function' !== typeof b.type.getDerivedStateFromProps &&
          'function' !== typeof this._instance.getSnapshotBeforeUpdate &&
          ('function' === typeof this._instance.componentWillReceiveProps &&
            this._instance.componentWillReceiveProps(c, a),
          'function' ===
            typeof this._instance.UNSAFE_componentWillReceiveProps &&
            this._instance.UNSAFE_componentWillReceiveProps(c, a))
        this._updateStateFromStaticLifecycle(c)
        var f = this._newState || e,
          k = !0
        this._forcedUpdate
          ? ((k = !0), (this._forcedUpdate = !1))
          : 'function' === typeof this._instance.shouldComponentUpdate
            ? (k = !!this._instance.shouldComponentUpdate(c, f, a))
            : d.prototype &&
              d.prototype.isPureReactComponent &&
              (k = !t(g, c) || !t(e, f))
        k &&
          'function' !== typeof b.type.getDerivedStateFromProps &&
          'function' !== typeof this._instance.getSnapshotBeforeUpdate &&
          ('function' === typeof this._instance.componentWillUpdate &&
            this._instance.componentWillUpdate(c, f, a),
          'function' === typeof this._instance.UNSAFE_componentWillUpdate &&
            this._instance.UNSAFE_componentWillUpdate(c, f, a))
        this._instance.context = a
        this._instance.props = c
        this._instance.state = f
        k && (this._rendered = this._instance.render())
      }
      a.prototype._updateStateFromStaticLifecycle = function(b) {
        var a = this._element.type
        if ('function' === typeof a.getDerivedStateFromProps) {
          var c = this._newState || this._instance.state
          b = a.getDerivedStateFromProps.call(null, b, c)
          null != b &&
            ((c = v({}, c, b)), (this._instance.state = this._newState = c))
        }
      }
      return a
    })()
  m.createRenderer = function() {
    return new m()
  }
  var H = (function() {
    function a(b) {
      u(this, a)
      this._renderer = b
      this._callbacks = []
    }
    a.prototype._enqueueCallback = function(a, d) {
      'function' === typeof a &&
        d &&
        this._callbacks.push({ callback: a, publicInstance: d })
    }
    a.prototype._invokeCallbacks = function() {
      var a = this._callbacks
      this._callbacks = []
      a.forEach(function(a) {
        a.callback.call(a.publicInstance)
      })
    }
    a.prototype.isMounted = function(a) {
      return !!this._renderer._element
    }
    a.prototype.enqueueForceUpdate = function(a, d, c) {
      this._enqueueCallback(d, a)
      this._renderer._forcedUpdate = !0
      this._renderer.render(this._renderer._element, this._renderer._context)
    }
    a.prototype.enqueueReplaceState = function(a, d, c, e) {
      this._enqueueCallback(c, a)
      this._renderer._newState = d
      this._renderer.render(this._renderer._element, this._renderer._context)
    }
    a.prototype.enqueueSetState = function(a, d, c, e) {
      this._enqueueCallback(c, a)
      c = this._renderer._newState || a.state
      'function' === typeof d && (d = d.call(a, c, a.props))
      null !== d &&
        void 0 !== d &&
        ((this._renderer._newState = v({}, c, d)),
        this._renderer.render(this._renderer._element, this._renderer._context))
    }
    return a
  })()
  e = ((e = { default: m }), m) || e
  return e.default ? e.default : e
})
